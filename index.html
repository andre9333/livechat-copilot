<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Terra AI Copilot</title>
    <script src="https://unpkg.com/@livechat/agent-app-sdk@1.6.3/dist/agentapp.umd.min.js"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg: #0f0f14;
            --card: #1a1a24;
            --border: #2a2a3a;
            --text: #f0f0f5;
            --text-dim: #8888a0;
            --accent: #00d4aa;
            --accent-hover: #00f0c0;
            --warning: #ffa726;
            --info: #42a5f5;
        }

        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg);
            color: var(--text);
            font-size: 13px;
            line-height: 1.5;
            min-height: 100vh;
        }

        /* Status bar */
        .status-bar {
            padding: 6px 16px;
            background: var(--card);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 10px;
            color: var(--text-dim);
        }

        .status-bar .status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            margin-right: 6px;
            display: inline-block;
        }

        .status-bar .status-dot.live {
            background: #4caf50;
        }

        .status-bar .status-dot.loading {
            background: var(--warning);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.4;
            }
        }

        /* Main response section */
        .response-hero {
            background: linear-gradient(135deg, #1a2a35 0%, #1a1a24 100%);
            border-bottom: 1px solid var(--border);
            padding: 16px;
        }

        .response-hero.updated {
            animation: highlight 0.5s ease;
        }

        @keyframes highlight {
            0% {
                background: linear-gradient(135deg, #1a4a35 0%, #1a1a24 100%);
            }

            100% {
                background: linear-gradient(135deg, #1a2a35 0%, #1a1a24 100%);
            }
        }

        .response-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--accent);
            margin-bottom: 8px;
        }

        .response-text {
            font-size: 14px;
            line-height: 1.6;
            color: var(--text);
            margin-bottom: 12px;
            max-height: 120px;
            overflow-y: auto;
        }

        .use-btn {
            width: 100%;
            padding: 14px 20px;
            background: var(--accent);
            color: #000;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.15s;
        }

        .use-btn:hover {
            background: var(--accent-hover);
        }

        .use-btn.copied {
            background: #2a4a3a;
            color: var(--accent);
        }

        /* Response actions container */
        .response-actions {
            display: flex;
            gap: 8px;
            padding: 12px 16px;
        }

        .regen-btn {
            padding: 10px 16px;
            background: transparent;
            color: var(--accent);
            border: 1px solid var(--accent);
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s;
        }

        .regen-btn:hover {
            background: rgba(59, 225, 183, 0.1);
        }

        .feedback-btn.thumbs-up.active {
            background: rgba(76, 175, 80, 0.2);
            border-color: #4caf50;
            color: #4caf50;
        }

        .feedback-btn.thumbs-down.active {
            background: rgba(244, 67, 54, 0.2);
            border-color: #f44336;
            color: #f44336;
        }

        .feedback-btn.edited.active {
            background: rgba(255, 167, 38, 0.2);
            border-color: #ffa726;
            color: #ffa726;
        }

        /* Alternatives */
        .alternatives {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
        }

        .alt-label {
            font-size: 10px;
            color: var(--text-dim);
            margin-bottom: 6px;
        }

        .alt-item {
            padding: 8px 10px;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 6px;
            margin-bottom: 6px;
            font-size: 12px;
            color: var(--text-dim);
            cursor: pointer;
            transition: all 0.15s;
        }

        .alt-item:hover {
            background: #252535;
            color: var(--text);
            border-color: var(--accent);
        }

        /* Context sections */
        .context-section {
            border-bottom: 1px solid var(--border);
        }

        .context-header {
            padding: 10px 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
        }

        .context-header:hover {
            background: var(--card);
        }

        .context-title {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-dim);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .context-badge {
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 9px;
            font-weight: 700;
        }

        .context-badge.match {
            background: rgba(0, 212, 170, 0.2);
            color: var(--accent);
        }

        .context-badge.new {
            background: rgba(255, 167, 38, 0.2);
            color: var(--warning);
        }

        .context-badge.product {
            background: rgba(66, 165, 245, 0.2);
            color: var(--info);
        }

        .context-arrow {
            font-size: 10px;
            color: var(--text-dim);
            transition: transform 0.2s;
        }

        .context-section.open .context-arrow {
            transform: rotate(180deg);
        }

        .context-body {
            padding: 0 16px 12px;
            display: none;
        }

        .context-section.open .context-body {
            display: block;
        }

        .context-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            font-size: 12px;
        }

        .context-row .label {
            color: var(--text-dim);
        }

        .context-row .value {
            font-weight: 500;
        }

        /* Action bar */
        .action-bar {
            padding: 10px 16px;
            background: rgba(255, 167, 38, 0.1);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: var(--warning);
        }

        /* States */
        .state-container {
            padding: 40px 20px;
            text-align: center;
        }

        .spinner {
            width: 24px;
            height: 24px;
            border: 2px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin: 0 auto 12px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .loading-spinner {
            width: 24px;
            height: 24px;
            border: 2px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin: 0 auto;
        }

        .state-text {
            color: var(--text-dim);
            font-size: 13px;
        }

        .state-icon {
            font-size: 28px;
            margin-bottom: 8px;
        }

        .error-box {
            padding: 12px 16px;
            background: rgba(255, 82, 82, 0.1);
            border: 1px solid #ff5252;
            border-radius: 8px;
            margin: 16px;
            color: #ff5252;
            font-size: 12px;
        }

        /* Test mode */
        .test-mode {
            padding: 16px;
        }

        .test-title {
            font-size: 11px;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
        }

        .form-group {
            margin-bottom: 10px;
        }

        .form-group label {
            font-size: 11px;
            color: var(--text-dim);
            display: block;
            margin-bottom: 4px;
        }

        .form-group input,
        .form-group textarea {
            width: 100%;
            padding: 10px;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            font-size: 13px;
            font-family: inherit;
        }

        .form-group input:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: var(--accent);
        }

        .test-btn {
            width: 100%;
            padding: 12px;
            background: var(--accent);
            color: #000;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
        }

        .test-btn:hover {
            background: var(--accent-hover);
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--accent);
            color: #000;
            padding: 10px 24px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        ::-webkit-scrollbar {
            width: 4px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }
    </style>
</head>

<body>
    <div id="app">
        <div class="state-container">
            <div class="spinner"></div>
            <div class="state-text">Connecting...</div>
        </div>
    </div>

    <div id="toast" class="toast"></div>

    <script>
        const API_BASE = 'https://livechataiagent.ngrok.app';
        // Bump this to confirm the LiveChat sidebar is loading the latest widget HTML (cache bust sanity check)
        const COPILOT_WIDGET_VERSION = '2025-12-18.1';

        let widget = null;
        let currentChatId = null;
        let currentProfile = null;
        let currentChatData = null;  // Store full chat data
        let currentTranscript = '';
        let lastMessageCount = 0;
        let lastResponse = null;
        let currentSuggestionId = null;  // Track current suggestion for feedback
        let pollInterval = null;
        let isRefreshing = false;
        let currentRequestId = 0;  // Track request ID to discard stale responses
        let lastFetchTime = 0;  // Throttle fetches

        // WebSocket connection for real-time updates
        let socket = null;
        let socketConnected = false;
        const FALLBACK_POLL_INTERVAL = 60000; // 60s fallback if WebSocket disconnects
        const MIN_FETCH_INTERVAL = 10000; // 10s minimum between fetches for same chat

        const isStandalone = window.self === window.top;

        async function init() {
            if (isStandalone) {
                showTestMode();
                return;
            }

            // Quick health check to see if backend is online
            try {
                const healthCheck = await fetch(API_BASE + '/api/health', {
                    method: 'GET',
                    signal: AbortSignal.timeout(3000)  // 3 second timeout
                }).catch(() => null);

                if (!healthCheck || !healthCheck.ok) {
                    showOffline();
                    return;
                }
            } catch (e) {
                showOffline();
                return;
            }

            // Initialize WebSocket connection
            initWebSocket();

            try {
                widget = await LiveChat.createDetailsWidget();
                widget.on('customer_profile', handleProfileChange);

                const profile = widget.getCustomerProfile();
                if (profile && profile.chat) {
                    handleProfileChange(profile);
                } else {
                    showWaiting();
                }
            } catch (error) {
                console.error('[Copilot] Init error:', error);
                showError('Widget must run inside LiveChat');
            }
        }

        function initWebSocket() {
            // Connect to WebSocket server for real-time updates
            try {
                socket = io(API_BASE, {
                    transports: ['websocket', 'polling'],
                    reconnection: true,
                    reconnectionAttempts: 5,
                    reconnectionDelay: 1000,
                    timeout: 10000,
                });

                socket.on('connect', () => {
                    console.log('[WebSocket] Connected:', socket.id);
                    socketConnected = true;

                    // If we already have a chat, join the room
                    if (currentChatId) {
                        socket.emit('join_chat', { chat_id: currentChatId });
                    }

                    // Clear fallback polling if it was running
                    if (pollInterval) {
                        clearInterval(pollInterval);
                        pollInterval = null;
                        console.log('[WebSocket] Cleared fallback polling');
                    }
                });

                socket.on('disconnect', (reason) => {
                    console.log('[WebSocket] Disconnected:', reason);
                    socketConnected = false;

                    // Start fallback polling when WebSocket disconnects
                    if (!pollInterval && currentChatId) {
                        console.log('[WebSocket] Starting fallback polling (60s)');
                        pollInterval = setInterval(checkForNewMessages, FALLBACK_POLL_INTERVAL);
                    }
                });

                socket.on('connect_error', (error) => {
                    console.error('[WebSocket] Connection error:', error.message);
                    socketConnected = false;
                });

                socket.on('joined', (data) => {
                    console.log('[WebSocket] Joined chat room:', data.chat_id);
                });

                // Handle real-time copilot updates from webhook
                socket.on('copilot_update', (data) => {
                    console.log('[WebSocket] Received copilot_update:', data.chat_id);

                    // Only process if it's for the current chat
                    if (data.chat_id !== currentChatId) {
                        console.log('[WebSocket] Ignoring update for different chat');
                        return;
                    }

                    // Process the copilot result
                    const copilotResult = data.copilot || {};

                    const result = {
                        suggestions: {
                            primary_response: copilotResult.suggestions?.primary_response || '',
                            alternatives: copilotResult.suggestions?.alternatives || [],
                            detected_intent: copilotResult.suggestions?.detected_intent || null,
                            recommended_actions: copilotResult.suggestions?.recommended_actions || [],
                            tool_calls: copilotResult.suggestions?.tool_calls || [],
                            context_notes: copilotResult.suggestions?.context_notes || [],
                            agent_product_links: copilotResult.suggestions?.agent_product_links || [],
                        },
                        customer_context: copilotResult.customer_context || null,
                        livechat_context: copilotResult.livechat_context || {},
                        suggestion_id: copilotResult.suggestion_id || null,
                    };

                    // Update message count if provided
                    if (data.message_count) {
                        lastMessageCount = data.message_count;
                    }

                    // Check if this is a new response
                    const newText = result.suggestions?.primary_response || '';
                    const oldText = lastResponse?.suggestions?.primary_response || '';
                    const isUpdate = lastResponse && newText !== oldText;

                    lastResponse = result;
                    currentSuggestionId = result.suggestion_id;

                    renderUI(result, isUpdate);

                    console.log('[WebSocket] UI updated with real-time suggestion');
                });

            } catch (error) {
                console.error('[WebSocket] Init error:', error);
                socketConnected = false;
            }
        }

        async function handleProfileChange(profile) {
            // Stop existing polling
            if (pollInterval) {
                clearInterval(pollInterval);
                pollInterval = null;
            }

            // Leave previous chat room if WebSocket connected
            if (socket && socketConnected && currentChatId) {
                socket.emit('leave_chat', { chat_id: currentChatId });
            }

            if (!profile || !profile.chat) {
                showWaiting();
                return;
            }

            // Check if it's a new chat
            const newChatId = profile.chat.chat_id;
            const isNewChat = newChatId !== currentChatId;
            const now = Date.now();

            if (isNewChat) {
                // Reset state for new chat - CRITICAL: increment request ID to invalidate old requests
                currentRequestId++;
                currentChatId = newChatId;
                currentProfile = profile;
                currentChatData = null;  // Clear old chat data!
                currentTranscript = '';
                lastMessageCount = 0;
                lastResponse = null;
                currentSuggestionId = null;
                lastFetchTime = 0;  // Reset fetch throttle for new chat

                console.log('[Copilot] Switched to new chat:', newChatId, 'requestId:', currentRequestId);
                showLoading();

                // Join the chat room for real-time updates
                if (socket && socketConnected) {
                    socket.emit('join_chat', { chat_id: newChatId });
                    console.log('[Copilot] Joined WebSocket room for chat:', newChatId);
                }

                // Fetch immediately for new chats
                lastFetchTime = now;
                await fetchChatAndAnalyze();

                // Only use polling as fallback if WebSocket is not connected
                if (!socketConnected) {
                    console.log('[Copilot] WebSocket not connected, using fallback polling (60s)');
                    pollInterval = setInterval(checkForNewMessages, FALLBACK_POLL_INTERVAL);
                }
            } else if (!socketConnected && (now - lastFetchTime) >= MIN_FETCH_INTERVAL) {
                // For existing chats without WebSocket: throttled refresh to catch new messages
                // This is a safety net - normally WebSocket pushes updates
                console.log('[Copilot] Throttled refresh for existing chat (no WebSocket)');
                lastFetchTime = now;
                await checkForNewMessages();
            }
            // With WebSocket connected, updates come via copilot_update events
        }

        async function fetchChatAndAnalyze() {
            if (!currentChatId) return;

            const chatIdAtStart = currentChatId;
            const requestIdAtStart = currentRequestId;

            try {
                // Fetch the full chat from our backend
                const chatResponse = await fetch(API_BASE + '/api/livechat/chat/' + currentChatId);

                if (!chatResponse.ok) {
                    console.error('[Copilot] Failed to fetch chat');
                    return;
                }

                const chatData = await chatResponse.json();

                // CRITICAL: Check if chat changed while we were fetching
                if (chatIdAtStart !== currentChatId || requestIdAtStart !== currentRequestId) {
                    console.log('[Copilot] Chat changed during fetch, discarding');
                    return;
                }

                currentChatData = chatData; // Store for AI context

                // Build transcript from messages
                const thread = chatData.thread || chatData;
                const events = thread.events || [];
                const messages = events.filter(e => e.type === 'message');

                // Check if there are new messages
                if (messages.length === lastMessageCount && lastResponse) {
                    // No new messages, don't refresh
                    return;
                }

                lastMessageCount = messages.length;

                // Build transcript with timestamps
                let transcript = '';
                let lastCustomerMessage = '';

                messages.forEach(msg => {
                    const isCustomer = msg.author_id?.startsWith('customer') ||
                        (msg.author_id && !msg.author_id.includes('@'));
                    const author = isCustomer ? 'Customer' : 'Agent';
                    const text = msg.text || '';
                    transcript += author + ': ' + text + '\n';

                    if (isCustomer) {
                        lastCustomerMessage = text;
                    }
                });

                currentTranscript = transcript;

                // Only get AI suggestions if there's a customer message
                if (lastCustomerMessage) {
                    await getSuggestions(lastCustomerMessage);
                }

            } catch (error) {
                console.error('[Copilot] Error fetching chat:', error);
            }
        }

        async function checkForNewMessages() {
            if (!currentChatId || isRefreshing) return;

            isRefreshing = true;
            const chatIdAtStart = currentChatId;
            const requestIdAtStart = currentRequestId;

            try {
                // Fetch chat to check message count
                const chatResponse = await fetch(API_BASE + '/api/livechat/chat/' + currentChatId);

                if (!chatResponse.ok) {
                    isRefreshing = false;
                    return;
                }

                const chatData = await chatResponse.json();

                // CRITICAL: Check if chat changed while we were polling
                if (chatIdAtStart !== currentChatId || requestIdAtStart !== currentRequestId) {
                    console.log('[Copilot] Chat changed during poll, discarding');
                    return;
                }

                currentChatData = chatData; // Always keep chat data fresh

                const thread = chatData.thread || chatData;
                const events = thread.events || [];
                const messages = events.filter(e => e.type === 'message');

                // Only re-analyze if message count changed
                if (messages.length !== lastMessageCount) {
                    console.log('[Copilot] New message detected!', messages.length, 'vs', lastMessageCount);
                    lastMessageCount = messages.length;

                    // Rebuild transcript
                    let transcript = '';
                    let lastCustomerMessage = '';

                    messages.forEach(msg => {
                        const isCustomer = msg.author_id?.startsWith('customer') ||
                            (msg.author_id && !msg.author_id.includes('@'));
                        const author = isCustomer ? 'Customer' : 'Agent';
                        const text = msg.text || '';
                        transcript += author + ': ' + text + '\n';

                        if (isCustomer) {
                            lastCustomerMessage = text;
                        }
                    });

                    currentTranscript = transcript;

                    // Re-analyze with new data only if there's a customer message
                    if (lastCustomerMessage) {
                        await getSuggestions(lastCustomerMessage);
                    }
                }

            } catch (error) {
                console.error('[Copilot] Poll error:', error);
            } finally {
                isRefreshing = false;
            }
        }

        async function getSuggestions(lastMessage) {
            // Capture current state at request time
            const requestId = currentRequestId;
            const chatIdAtRequest = currentChatId;

            try {
                // Build comprehensive request with full chat data
                const requestBody = {
                    chat_id: currentChatId,
                    message_text: lastMessage || '',
                    author_type: 'customer',
                    transcript_so_far: currentTranscript,
                    customer_email: currentProfile?.email || null,
                    customer_name: currentProfile?.name || 'Visitor',
                    // CRITICAL: Include full chat data for context
                    chat_data: currentChatData
                };

                console.log('[Copilot] Sending request with', {
                    chat_id: currentChatId,
                    transcript_length: currentTranscript.length,
                    messages: lastMessageCount,
                    has_chat_data: !!currentChatData
                });

                // STAGE 1: Get quick customer context immediately (fast)
                // IMPORTANT: Include chat_data so we can extract email from pre-chat form
                const contextPromise = fetch(API_BASE + '/api/copilot/context', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        customer_email: requestBody.customer_email,
                        customer_name: requestBody.customer_name,
                        customer_company: currentProfile?.fields?.company || null,
                        transcript: currentTranscript,
                        chat_data: currentChatData  // Needed to extract email from pre-chat form
                    })
                });

                // STAGE 2: Get AI suggestions (slower)
                const suggestionsPromise = fetch(API_BASE + '/api/copilot/process-message', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                // Show quick context as soon as it's ready
                try {
                    const contextResponse = await contextPromise;
                    if (contextResponse.ok) {
                        const contextData = await contextResponse.json();

                        // Check for stale response
                        if (requestId === currentRequestId && chatIdAtRequest === currentChatId) {
                            // Normalize API response (supports both legacy and new shapes)
                            const ctx = contextData && (contextData.customer_context || contextData.context || contextData);
                            renderPartialUI(ctx, lastMessage);
                        }
                    }
                } catch (e) {
                    console.log('[Copilot] Context fetch failed, waiting for full response');
                }

                // Now wait for full AI suggestions
                const response = await suggestionsPromise;

                if (!response.ok) throw new Error('API error');

                const raw = await response.json();

                // Map API response into the widget's expected shape
                const result = {
                    suggestions: {
                        primary_response: raw.suggestions?.primary_response
                            || raw.suggestion?.suggestion
                            || '',
                        alternatives: raw.suggestions?.alternatives
                            || raw.suggestion?.alternatives
                            || [],
                        detected_intent: raw.suggestions?.detected_intent
                            || raw.suggestion?.intent
                            || null,
                        recommended_actions: raw.suggestions?.recommended_actions
                            || raw.suggestion?.recommended_actions
                            || [],
                        tool_calls: raw.suggestions?.tool_calls
                            || raw.suggestion?.tool_calls
                            || [],
                        context_notes: raw.suggestions?.context_notes
                            || raw.suggestion?.context_notes
                            || [],
                        agent_product_links: raw.suggestions?.agent_product_links
                            || raw.suggestion?.agent_product_links
                            || [],
                        confidence: raw.suggestions?.confidence
                            || raw.suggestion?.confidence
                            || null,
                        send_ready: raw.suggestions?.send_ready
                            || raw.suggestion?.send_ready
                            || false,
                        facts_used: raw.suggestions?.facts_used
                            || raw.suggestion?.facts_used
                            || [],
                        checks: raw.suggestions?.checks
                            || raw.suggestion?.checks
                            || {},
                        similar_examples: raw.suggestions?.similar_examples
                            || raw.suggestion?.similar_examples
                            || [],
                        prefetched_product_page: raw.suggestions?.prefetched_product_page
                            || raw.suggestion?.prefetched_product_page
                            || null,
                        email_required: raw.suggestions?.email_required
                            || raw.suggestion?.email_required
                            || false,
                        company_analysis: raw.suggestions?.company_analysis
                            || raw.suggestion?.company_analysis
                            || null,
                    },
                    customer_context: raw.customer_context
                        || raw.context
                        || null,
                    livechat_context: raw.livechat_context || {},
                    suggestion_id: raw.suggestion_id || raw.suggestion?.suggestion_id || null,
                };

                // CRITICAL: Discard stale responses from old chats
                if (requestId !== currentRequestId || chatIdAtRequest !== currentChatId) {
                    console.log('[Copilot] Discarding stale response for chat:', chatIdAtRequest,
                        '(current:', currentChatId, ')');
                    return;
                }

                // Check if response actually changed
                const newText = result.suggestions?.primary_response || '';
                const oldText = lastResponse?.suggestions?.primary_response || '';
                const isUpdate = lastResponse && newText !== oldText;

                lastResponse = result;
                renderUI(result, isUpdate);

            } catch (error) {
                console.error('[Copilot] Error getting suggestions:', error);
                if (!lastResponse) {
                    // Check if it's a connection error (backend offline)
                    if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError') || error.name === 'TypeError') {
                        showOffline();
                    } else {
                        showError('Failed to get suggestions');
                    }
                }
            }
        }

        function renderPartialUI(contextData, lastMessage) {
            // Render quick context immediately with a "generating" placeholder for AI
            const ctx = contextData || {};
            const app = document.getElementById('app');

            let html = '';

            // Show "Generating..." for the response
            html += '<div class="response-hero">';
            html += '<div class="response-label">âœ¨ GENERATING RESPONSE...</div>';
            html += '<div class="response-text" style="color: var(--text-dim); font-style: italic;">';
            if (lastMessage) {
                html += 'Analyzing: "' + escapeHtml(lastMessage.substring(0, 80)) + (lastMessage.length > 80 ? '...' : '') + '"';
            } else {
                html += 'Preparing response...';
            }
            html += '</div>';
            html += '<div style="padding: 12px 16px;"><div class="loading-spinner"></div></div>';
            html += '</div>';

            // Show basic customer info immediately (no A4 lookup)
            if (ctx.client) {
                html += '<div class="context-section open">';
                html += '<div class="context-header" onclick="toggleSection(this.parentElement)">';
                html += '<div class="context-title">ðŸ‘¤ Customer</div>';
                html += '<span class="context-arrow">â–¼</span>';
                html += '</div>';
                html += '<div class="context-body">';
                if (ctx.client.name) {
                    html += '<div class="context-row"><span class="label">Name</span><span class="value">' + escapeHtml(ctx.client.name) + '</span></div>';
                }
                if (ctx.client.company) {
                    html += '<div class="context-row"><span class="label">Company</span><span class="value">' + escapeHtml(ctx.client.company) + '</span></div>';
                }
                if (ctx.client.email) {
                    html += '<div class="context-row"><span class="label">Email</span><span class="value">' + escapeHtml(ctx.client.email) + '</span></div>';
                }
                html += '</div></div>';
            }

            // What we're checking (loading state)
            html += '<div class="context-section open">';
            html += '<div class="context-header" onclick="toggleSection(this.parentElement)">';
            html += '<div class="context-title">ðŸ”Ž What Copilot is checking <span class="context-badge product">IN PROGRESS</span></div>';
            html += '<span class="context-arrow">â–¼</span>';
            html += '</div>';
            html += '<div class="context-body">';
            html += '<div style="font-size: 12px; color: var(--text); margin-bottom: 6px; padding: 6px; background: var(--bg); border-radius: 4px;">â€¢ Similar chat examples (vector search)</div>';
            html += '<div style="font-size: 12px; color: var(--text); margin-bottom: 6px; padding: 6px; background: var(--bg); border-radius: 4px;">â€¢ Customer journey URLs (current/referrer/viewed)</div>';
            html += '<div style="font-size: 12px; color: var(--text); margin-bottom: 6px; padding: 6px; background: var(--bg); border-radius: 4px;">â€¢ Terra product page scrape (if needed for specs/pricing)</div>';
            html += '</div></div>';

            app.innerHTML = html;
        }

        function renderUI(result, isUpdate) {
            const ctx = result.customer_context || {};
            const sug = result.suggestions || {};
            const lc = result.livechat_context || {};
            const app = document.getElementById('app');

            let html = '';

            // Minimal status bar
            html += '<div class="status-bar">';
            html += '<span><span class="status-dot live"></span>' + lastMessageCount + ' messages â€¢ v' + COPILOT_WIDGET_VERSION + '</span>';
            html += '<span>' + escapeHtml(currentProfile?.name || 'Visitor') + '</span>';
            html += '</div>';

            // Response
            if (sug.primary_response) {
                html += '<div class="response-hero' + (isUpdate ? ' updated' : '') + '">';
                html += '<div class="response-label">âœ¨ SUGGESTED RESPONSE</div>';
                html += '<div class="response-text">' + escapeHtml(sug.primary_response) + '</div>';
                html += '<div class="response-actions">';
                html += '<button class="use-btn" onclick="useResponse(this, \'' + escapeJs(sug.primary_response) + '\')">';
                html += 'ðŸ“‹ USE THIS RESPONSE</button>';
                html += '<button class="regen-btn" onclick="regenerateResponse()" title="Get a fresh AI response">';
                html += 'ðŸ”„ Regenerate</button>';
                html += '</div>';
                html += '</div>';

                // Store suggestion_id for feedback
                currentSuggestionId = result.suggestion_id || null;
            }

            // Action recommendation
            if (sug.recommended_actions && sug.recommended_actions.length > 0) {
                const action = sug.recommended_actions[0];
                if (action && action.tool && action.tool !== 'no_action') {
                    html += '<div class="action-bar">';
                    html += 'ðŸ’¡ <strong>' + formatAction(action.tool) + '</strong>';
                    if (action.reason) html += ' â€¢ ' + escapeHtml(action.reason);
                    html += '</div>';
                }
            }

            // Alternatives removed - only show recommended response

            // COPILOT TRACE / WHAT WAS CHECKED
            const checks = sug.checks || {};
            const vec = checks.vector_search || {};
            const urls = checks.customer_urls || [];
            const prefetch = checks.prefetch_product_page || {};
            const similar = sug.similar_examples || [];
            const facts = sug.facts_used || [];

            html += '<div class="context-section open">';
            html += '<div class="context-header" onclick="toggleSection(this.parentElement)">';
            html += '<div class="context-title">ðŸ”Ž What Copilot Checked</div>';
            html += '<span class="context-arrow">â–¼</span>';
            html += '</div>';
            html += '<div class="context-body">';

            // Send-ready + confidence
            const confPct = (typeof sug.confidence === "number") ? Math.round(sug.confidence * 100) : null;
            const sendReady = !!sug.send_ready;
            html += '<div style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:8px;">';
            html += '<span class="context-badge product" style="padding:4px 8px;">' + (sendReady ? 'SEND READY' : 'REVIEW') + '</span>';
            if (confPct !== null) {
                html += '<span class="context-badge" style="background: rgba(66, 165, 245, 0.2); color: var(--info); padding:4px 8px;">' + confPct + '% confidence</span>';
            }
            html += '</div>';

            // Vector search
            const topSim = (typeof vec.top_similarity === "number") ? Math.round(vec.top_similarity * 100) : null;
            html += '<div class="context-row"><span class="label">Similar chats</span><span class="value">' +
                (vec.examples_found ? (vec.examples_found + ' found' + (topSim !== null ? ' â€¢ top ' + topSim + '%' : '')) : 'No matches') +
                '</span></div>';

            // URLs
            html += '<div class="context-row"><span class="label">Customer URLs</span><span class="value">' + (urls.length ? (urls.length + ' captured') : 'None captured') + '</span></div>';
            if (urls.length) {
                html += '<div style="font-size: 11px; color: var(--text-dim); margin-top: 6px; padding: 6px; background: var(--bg); border-radius: 6px;">';
                urls.slice(0, 3).forEach(function (u) {
                    const short = (u || '').replace(/^https?:\/\//, '').split('?')[0];
                    html += 'â€¢ ' + escapeHtml(short.slice(0, 70)) + '<br>';
                });
                html += '</div>';
            }

            // Prefetch product page scrape
            if (prefetch && (prefetch.attempted || prefetch.success)) {
                const status = prefetch.success ? 'âœ“ scraped' : (prefetch.attempted ? 'attempted' : 'not attempted');
                html += '<div class="context-row"><span class="label">Product page scrape</span><span class="value">' + escapeHtml(status) + '</span></div>';
            }

            // Evidence from prefetched product scrape
            if (sug.prefetched_product_page && !sug.prefetched_product_page.error) {
                const p = sug.prefetched_product_page;
                html += '<div style="margin-top:10px;padding:8px;background:var(--bg);border-radius:8px;border-left:3px solid var(--accent);">';
                html += '<div style="font-weight:700;color:var(--text);margin-bottom:4px;">ðŸ›’ Product evidence</div>';
                if (p.product_name) html += '<div style="font-size:12px;color:var(--text);">' + escapeHtml(p.product_name) + '</div>';
                if (p.part_number) html += '<div style="font-size:12px;color:var(--text-dim);">Part #: <strong style="color:var(--text);">' + escapeHtml(p.part_number) + '</strong></div>';
                if (p.price) html += '<div style="font-size:12px;color:var(--accent);font-weight:700;">Price: ' + escapeHtml(p.price) + '</div>';
                html += '</div>';
            }

            // Facts used (short list the model claims it relied on)
            if (facts && facts.length) {
                html += '<div style="margin-top:10px;">';
                html += '<div style="font-size:11px;color:var(--text-dim);margin-bottom:6px;">Facts used</div>';
                facts.slice(0, 6).forEach(function (f) {
                    html += '<div style="font-size: 12px; color: var(--text); margin-bottom: 6px; padding: 6px; background: var(--bg); border-radius: 4px;">â€¢ ' + escapeHtml(f) + '</div>';
                });
                html += '</div>';
            }

            html += '</div></div>';

            // Similar examples (glimpse)
            if (similar && similar.length) {
                html += '<div class="context-section">';
                html += '<div class="context-header" onclick="toggleSection(this.parentElement)">';
                html += '<div class="context-title">ðŸ“š Similar Examples (' + similar.length + ')</div>';
                html += '<span class="context-arrow">â–¶</span>';
                html += '</div>';
                html += '<div class="context-body" style="display: none;">';
                similar.slice(0, 2).forEach(function (ex) {
                    const simPct = (typeof ex.similarity === "number") ? Math.round(ex.similarity * 100) : 0;
                    html += '<div style="padding:8px;background:var(--bg);border-radius:8px;margin-bottom:8px;border-left:3px solid var(--info);">';
                    html += '<div style="display:flex;justify-content:space-between;gap:10px;align-items:center;">';
                    html += '<span style="font-weight:700;color:var(--text);">' + simPct + '% match</span>';
                    if (ex.search_method) html += '<span style="font-size:10px;color:var(--text-dim);text-transform:uppercase;">' + escapeHtml(ex.search_method) + '</span>';
                    html += '</div>';
                    if (ex.customer_preview) {
                        html += '<div style="font-size:11px;color:var(--text-dim);margin-top:6px;">Customer: ' + escapeHtml(ex.customer_preview) + '</div>';
                    }
                    if (ex.agent_preview) {
                        html += '<div style="font-size:11px;color:var(--text-dim);margin-top:6px;">Agent: ' + escapeHtml(ex.agent_preview) + '</div>';
                    }
                    html += '</div>';
                });
                html += '</div></div>';
            }

            // Tool Calls - show what the AI looked up dynamically
            if (sug.tool_calls && sug.tool_calls.length > 0) {
                html += '<div class="context-section">';
                html += '<div class="context-header" onclick="toggleSection(this.parentElement)">';
                html += '<div class="context-title">ðŸ”§ AI Searched (' + sug.tool_calls.length + ' lookups)</div>';
                html += '<span class="context-arrow">â–¶</span>';
                html += '</div>';
                html += '<div class="context-body" style="display: none;">';
                sug.tool_calls.forEach(function (tc) {
                    var isDeduped = !!tc.deduped;
                    var hasError = tc.result && tc.result.error;
                    var status = isDeduped ? 'â†º' : (hasError ? 'âœ—' : 'âœ“');
                    var statusColor = isDeduped ? 'var(--text-dim)' : (hasError ? '#f44336' : '#4CAF50');
                    html += '<div style="font-size: 11px; color: var(--text-muted); margin-bottom: 4px; padding: 4px; background: var(--bg); border-radius: 4px;">';
                    html += '<span style="color: ' + statusColor + ';">' + status + '</span> ';
                    html += '<strong>' + escapeHtml(tc.tool) + '</strong>';
                    if (tc.args) {
                        var argStr = Object.entries(tc.args).map(function (e) { return e[0] + '=' + e[1]; }).join(', ');
                        html += ' <span style="opacity: 0.7;">(' + escapeHtml(argStr) + ')</span>';
                    }
                    if (tc.result && tc.result.error) {
                        html += '<div style="margin-top:4px;color:#f44336;opacity:0.9;">' + escapeHtml(String(tc.result.error).slice(0, 180)) + '</div>';
                    }
                    html += '</div>';
                });
                html += '</div></div>';
            }

            // Agent-only: related product links (only present when context warrants it)
            if (sug.agent_product_links && sug.agent_product_links.length > 0) {
                html += '<div class="context-section open">';
                html += '<div class="context-header" onclick="toggleSection(this.parentElement)">';
                html += '<div class="context-title">ðŸ”— Related Products (Agent-only)</div>';
                html += '<span class="context-arrow">â–¼</span>';
                html += '</div>';
                html += '<div class="context-body">';
                sug.agent_product_links.slice(0, 5).forEach(function (p) {
                    var url = p.product_url || '';
                    var pn = p.part_number || '';
                    var name = p.product_name || '';
                    html += '<div style="padding:6px 8px;background:var(--bg);border-radius:6px;margin-bottom:6px;border-left:3px solid var(--info);">';
                    if (url) {
                        html += '<div style="font-weight:600;"><a href="' + escapeHtml(url) + '" target="_blank" style="color: var(--accent); text-decoration: none;">' + escapeHtml(pn || url) + '</a></div>';
                    } else {
                        html += '<div style="font-weight:600;color:var(--text);">' + escapeHtml(pn) + '</div>';
                    }
                    if (name) {
                        html += '<div style="font-size:10px;color:var(--text-dim);margin-top:2px;">' + escapeHtml(name) + '</div>';
                    }
                    html += '</div>';
                });
                html += '</div></div>';
            }

            // Agent Notes - actionable insights
            if (sug.context_notes && sug.context_notes.length > 0) {
                html += '<div class="context-section open">';
                html += '<div class="context-header" onclick="toggleSection(this.parentElement)">';
                html += '<div class="context-title">ðŸ’¡ Agent Notes</div>';
                html += '<span class="context-arrow">â–¼</span>';
                html += '</div>';
                html += '<div class="context-body">';
                sug.context_notes.forEach(function (note) {
                    html += '<div style="font-size: 12px; color: var(--text); margin-bottom: 6px; padding: 6px; background: var(--bg); border-radius: 4px;">â€¢ ' + escapeHtml(note) + '</div>';
                });
                html += '</div></div>';
            }

            if (!sug.primary_response) {
                html = '<div class="state-container">';
                html += '<div class="state-icon">ðŸ’¬</div>';
                html += '<div class="state-text">Waiting for customer message...</div>';
                html += '</div>';
            }

            app.innerHTML = html;
        }

        function toggleSection(el) {
            el.classList.toggle('open');
        }

        async function regenerateResponse() {
            // Clear cached response to force fresh generation
            lastResponse = null;
            currentRequestId++;  // Invalidate any in-flight requests

            // Show loading state
            const app = document.getElementById('app');
            app.innerHTML = '<div class="state-container"><div class="spinner"></div><div class="state-text">Generating new response...</div></div>';

            // Build transcript and get last customer message
            if (currentChatData) {
                const thread = currentChatData.thread || currentChatData;
                const events = thread.events || [];
                const messages = events.filter(e => e.type === 'message');

                let lastCustomerMessage = '';
                messages.forEach(msg => {
                    const isCustomer = msg.author_id?.startsWith('customer') ||
                        (msg.author_id && !msg.author_id.includes('@'));
                    if (isCustomer && msg.text) {
                        lastCustomerMessage = msg.text;
                    }
                });

                if (lastCustomerMessage) {
                    await getSuggestions(lastCustomerMessage);
                    showToast('New response generated!');
                    return;
                }
            }

            showToast('No message to regenerate from');
        }

        async function useResponse(btn, text) {
            // Log as "used" feedback
            if (currentSuggestionId) {
                await sendFeedback('used', false);  // false = don't show toast
            }

            if (widget) {
                try {
                    await widget.putMessage(text);
                    showToast('Added to message box!');
                    if (btn) {
                        btn.classList.add('copied');
                        btn.textContent = 'âœ“ ADDED';
                        setTimeout(function () {
                            btn.classList.remove('copied');
                            btn.innerHTML = 'ðŸ“‹ USE THIS RESPONSE';
                        }, 2000);
                    }
                } catch (e) {
                    copyToClipboard(text);
                }
            } else {
                copyToClipboard(text);
            }
        }

        async function sendFeedback(feedbackType, showToastMsg = true) {
            if (!currentSuggestionId) {
                console.warn('[Copilot] No suggestion_id available for feedback');
                return;
            }

            try {
                const response = await fetch(API_BASE + '/api/feedback/explicit', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        suggestion_id: currentSuggestionId,
                        feedback_type: feedbackType
                    })
                });

                if (response.ok) {
                    // Visual feedback
                    const buttons = document.querySelectorAll('.feedback-btn');
                    buttons.forEach(btn => btn.classList.remove('active'));

                    const activeBtn = document.querySelector(`.feedback-btn.${feedbackType === 'thumbs_up' ? 'thumbs-up' : feedbackType === 'thumbs_down' ? 'thumbs-down' : 'edited'}`);
                    if (activeBtn) {
                        activeBtn.classList.add('active');
                    }

                    if (showToastMsg) {
                        const messages = {
                            'thumbs_up': 'Thanks for the feedback! ðŸ‘',
                            'thumbs_down': 'Thanks for the feedback! ðŸ‘Ž',
                            'edited': 'Thanks for the feedback! âœï¸',
                            'used': ''  // Silent for auto-logging
                        };
                        if (messages[feedbackType]) {
                            showToast(messages[feedbackType]);
                        }
                    }
                } else {
                    console.error('[Copilot] Feedback API error:', response.status);
                }
            } catch (error) {
                console.error('[Copilot] Error sending feedback:', error);
            }
        }

        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(function () {
                showToast('Copied to clipboard!');
            });
        }

        function formatAction(tool) {
            const actions = {
                'lookup_quote': 'Look up quote',
                'lookup_order': 'Look up order',
                'create_quote': 'Create quote',
                'transfer_sales': 'Transfer to Sales',
                'transfer_engineering': 'Transfer to Engineering',
                'send_link': 'Send product link',
                'schedule_callback': 'Schedule callback'
            };
            return actions[tool] || tool;
        }

        function showToast(msg) {
            const toast = document.getElementById('toast');
            toast.textContent = msg;
            toast.classList.add('show');
            setTimeout(function () { toast.classList.remove('show'); }, 2500);
        }

        function showLoading() {
            document.getElementById('app').innerHTML =
                '<div class="state-container"><div class="spinner"></div><div class="state-text">Analyzing chat...</div></div>';
        }

        function showWaiting() {
            document.getElementById('app').innerHTML =
                '<div class="state-container"><div class="state-icon">ðŸ’¬</div><div class="state-text">Select a chat to get started</div></div>';
        }

        function showError(msg) {
            document.getElementById('app').innerHTML = '<div class="error-box">' + escapeHtml(msg) + '</div>';
        }

        function showOffline() {
            document.getElementById('app').innerHTML = `
                <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; padding: 24px; text-align: center;">
                    <div style="font-size: 48px; margin-bottom: 16px; opacity: 0.5;">ðŸ”Œ</div>
                    <div style="font-size: 16px; font-weight: 600; color: var(--text); margin-bottom: 8px;">Copilot Offline</div>
                    <div style="font-size: 12px; color: var(--text-dim); max-width: 240px; line-height: 1.5;">
                        Please contact <strong>Andre Vignau</strong><br>
                        <a href="mailto:andre@terrauniversal.com" style="color: var(--accent);">andre@terrauniversal.com</a><br>
                        to start the AI Copilot server.
                    </div>
                    <button onclick="location.reload()" style="margin-top: 16px; padding: 8px 16px; background: var(--accent); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 12px;">
                        Retry Connection
                    </button>
                </div>
            `;
        }

        // ============ TEST MODE ============
        function showTestMode() {
            const app = document.getElementById('app');
            app.innerHTML = '<div class="test-mode">' +
                '<div class="test-title">ðŸ§ª Standalone Test Mode</div>' +
                '<div class="form-group">' +
                '<label>Customer Email</label>' +
                '<input type="email" id="test-email" placeholder="customer@company.com">' +
                '</div>' +
                '<div class="form-group">' +
                '<label>Customer Name</label>' +
                '<input type="text" id="test-name" value="Test Customer">' +
                '</div>' +
                '<div class="form-group">' +
                '<label>Customer Message</label>' +
                '<textarea id="test-message" rows="3" placeholder="I need a quote for a cleanroom..."></textarea>' +
                '</div>' +
                '<button class="test-btn" onclick="runTest()">Get AI Suggestions</button>' +
                '</div>' +
                '<div id="test-results"></div>';
        }

        async function runTest() {
            const email = document.getElementById('test-email').value;
            const name = document.getElementById('test-name').value || 'Test Customer';
            const message = document.getElementById('test-message').value;

            if (!message.trim()) {
                showToast('Enter a message first');
                return;
            }

            currentProfile = { email: email, name: name };
            currentTranscript = 'Customer: ' + message;

            document.getElementById('test-results').innerHTML =
                '<div class="state-container"><div class="spinner"></div><div class="state-text">Analyzing...</div></div>';

            try {
                const response = await fetch(API_BASE + '/api/copilot/process-message', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chat_id: 'test-' + Date.now(),
                        message_text: message,
                        author_type: 'customer',
                        transcript_so_far: currentTranscript,
                        customer_email: email || null,
                        customer_name: name
                    })
                });

                if (!response.ok) throw new Error('API error: ' + response.status);

                const result = await response.json();
                const ctx = result.customer_context || {};
                const sug = result.suggestions || {};

                let html = '';

                if (sug.primary_response) {
                    html += '<div class="response-hero">';
                    html += '<div class="response-label">âœ¨ SUGGESTED RESPONSE</div>';
                    html += '<div class="response-text">' + escapeHtml(sug.primary_response) + '</div>';
                    html += '<button class="use-btn" onclick="copyToClipboard(\'' + escapeJs(sug.primary_response) + '\')">';
                    html += 'ðŸ“‹ COPY RESPONSE</button>';
                    html += '</div>';

                    if (sug.alternatives && sug.alternatives.length > 0) {
                        html += '<div class="alternatives">';
                        html += '<div class="alt-label">Alternatives:</div>';
                        sug.alternatives.slice(0, 2).forEach(function (alt) {
                            html += '<div class="alt-item" onclick="copyToClipboard(\'' + escapeJs(alt) + '\')">' + escapeHtml(alt) + '</div>';
                        });
                        html += '</div>';
                    }

                    html += '<div style="padding: 12px 16px; font-size: 12px; color: var(--text-dim);">';
                    const checks = sug.checks || {};
                    const vec = checks.vector_search || {};
                    const topSim = (typeof vec.top_similarity === "number") ? Math.round(vec.top_similarity * 100) : null;
                    html += 'âœ“ Copilot checks: ' + (vec.examples_found ? (vec.examples_found + ' examples' + (topSim !== null ? ' â€¢ top ' + topSim + '%' : '')) : 'no vector matches');
                    html += '</div>';
                } else {
                    html = '<div class="error-box">No suggestion generated.</div>';
                }

                document.getElementById('test-results').innerHTML = html;

            } catch (error) {
                document.getElementById('test-results').innerHTML =
                    '<div class="error-box">Error: ' + escapeHtml(error.message) + '</div>';
            }
        }

        function escapeHtml(text) {
            if (!text) return '';
            var div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function escapeJs(text) {
            if (!text) return '';
            return text.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/\n/g, '\\n').replace(/\r/g, '');
        }

        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>

</html>